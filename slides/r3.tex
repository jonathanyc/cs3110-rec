\documentclass{beamer}
\mode<presentation> {
  % Beamer theme.
  \usetheme{default}
  \usecolortheme{beaver}
  % Images.
  \usepackage{graphicx}
  % \toprule, \midrule, \bottomrule
  \usepackage{booktabs}
  % Symbols.
  \usepackage{amssymb}
  \usepackage{pifont}
  % Colors!
  \usepackage{color}
  % Code!
  \usepackage{listings}
  \lstset{
    basicstyle=\ttfamily,
    mathescape,
    numbers=left
  }

  \title[Recitation 3]{Recitation 3: Types, Modules, and Priority Queues }
  \author{Eric Wu, Jonathan Chan}
  \institute[Cornell] { CS 3110 }
  \date{Feb. 11, 2016}
}

% Macros.
\catcode``=\active
\def`#1`{\texttt{#1}}
\newcommand{\redx}{{\color{red} \ding{55}}}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Itinerary}
\tableofcontents
\end{frame}

\section{Types}

\begin{frame}[fragile]
\frametitle{Type or type error?}

\begin{lstlisting}
type 'a list =
  | Cons of 'a * 'a list
  | Empty
\end{lstlisting}
\pause

\begin{itemize}
\item \verb|1 + 3| \pause : \verb|int| \pause
\item \verb|[1; 2; 3]| \pause : \verb|int list| \pause
\item \verb|(42, "the answer")| \pause : \verb|int * string| \pause
\item \verb|1 + [1; 2; 3]| \pause : \redx \pause
\item \verb|(42, 7) + (50, 9)| \pause : \redx \pause
\item \verb|Cons ("Eric", Cons ("Jonathan", Empty))| \pause \\: \verb|string list| \pause
\item \verb|Cons (7, Cons (false, Empty))| \pause : \redx
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Solving for types}
\begin{lstlisting}
let g x =
  "These are some cool numbers: " ^
  string_of_float x

let h (a, b) =
  int_of_float (a +. float_of_string b)
  
let f x =
  g (fst x) ^ string_of_int (h x)
\end{lstlisting}
\pause

\begin{itemize}
\item \verb|g| \pause : \verb|float| $\rightarrow$ \verb|string| \pause
\item \verb|h| \pause : \verb|float| $\times$ \verb|string| $\rightarrow$ \verb|int| \pause
\item \verb|f| \pause : $t_1 \times t_2 \rightarrow$ \verb|string| \pause
\begin{itemize}
\item $t_1$ \pause : \verb|float| \quad ($g$ : $t_1 \rightarrow$ \verb|string|) \pause
\item $t_2$ \pause : \verb|string|  \quad ($h$ : \verb|_| $\times t_2 \rightarrow$ \verb|int|) \pause
\item \verb|f| \pause : \verb|float| $\times$ \verb|string| $\rightarrow$ \verb|string|
\end{itemize}
\end{itemize}
\end{frame}

\section{Modules}

\section{Priority Queues}

\begin{frame}[fragile]
\frametitle{Introduction to Priority Queues}
A priority queue is an \textit{abstract data type} that stores values and their priorities.
We'll use \verb|float|s for priorities here and let bigger floats be higher priorities, but this is up to you.

A priority queue supports the following operations:
\begin{itemize}
\item \textsc{Insert} : $\alpha$ \verb|PrioQ.t| $\rightarrow$ \verb|float| $\rightarrow \alpha \rightarrow$ \verb|PrioQ.t|
\item \textsc{Peek} : $\alpha$ \verb|PrioQ.t| $\rightarrow \alpha$ \verb|option|
\item \textsc{Remove} : $\alpha$ \verb|PrioQ.t| $\rightarrow \alpha$ \verb|PrioQ.t|
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementation: Idea}
\textit{Idea}: Implement a priority queue using a binary tree.
\begin{itemize}
\item The element at the top of the tree will be the one with the highest priority.
\item An element's parents will always have higher priority than them (don't know about siblings).
\item Then in \textsc{Insert}, if the priority of the new element is greater than the element at the top, we put the new element at the top and insert the other into the left or right subtree (recursion!).
\item If it's less, we insert the new element into the left or right subtree.
\item \textsc{Remove} has the choice of two elements to replace the top element with. We need to decide based on their relative priorities.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementation: Data Type}
\begin{lstlisting}
type 'a t =
  | Node of float * 'a * 'a t * 'a t
  | Empty
\end{lstlisting}

Some examples:
\begin{itemize}
\item \verb|Empty|
\item \verb|Node (111.0, "1110", Empty, Empty)|
\item \verb|Node (infinity, "Happiness",| \\
      \verb|  Node (100.0, "Money", Empty, Empty),| \\
      \verb|  Empty)|
\end{itemize}

How would we...
\begin{itemize}
\item \textsc{Remove} from both?
\item \textsc{Insert} \verb|"3110"| with priority $311.0$ into both?
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementation: \textsc{Peek}}
\begin{lstlisting}
type 'a t =
  | Node of float * 'a * 'a t * 'a t
  | Empty

val peek : 'a t -> 'a option
\end{lstlisting}
\pause
\textsc{Peek} should remove the element with the highest priority.
Where is it?
\pause

\textit{Recall:} 
"The element at the top of the tree will be the one with the highest priority."
\pause

\begin{lstlisting}
let peek = function
  | Empty -> None
  | Node (_, x, _, _) -> Some x
\end{lstlisting}

\pause
How fast is \textsc{Peek} relative to the size of the tree?
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementation: \textsc{Insert}}
\begin{lstlisting}
type 'a t =
  | Node of float * 'a * 'a t * 'a t
  | Empty

val insert : 'a t -> float -> 'a -> 'a t
\end{lstlisting}
\pause

\textsc{Insert} needs to preserve the properties.

\textit{Recall:} 
\begin{itemize}
\item The element at the top of the tree will be the one with the highest priority.
\item An element's parents will always have higher priority than them (don't know about siblings).
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementation: \textsc{Insert}}
\begin{lstlisting}
type 'a t =
  | Node of float * 'a * 'a t * 'a t
  | Empty

val insert : 'a t -> float -> 'a -> 'a t
\end{lstlisting}

Our plan was:
\begin{itemize}
\item If the priority of the new element is greater than the element at the top, we put the new element at the top and insert the other into the left or right subtree (recursion!).
\item If it's less, we insert the new element into the left or right subtree.
\end{itemize}
\pause
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementation: \textsc{Insert}}
\begin{lstlisting}
type 'a t =
  | Node of float * 'a * 'a t * 'a t
  | Empty

val insert : 'a t -> float -> 'a -> 'a t

let rec insert q p x =
  match q with
  | Empty -> Node (p, x, Empty, Empty)
  | Node (p', x', l, r) ->
    if p >= p' then
      Node (p, x, insert r p' x', l)
    else Node (p', x', insert r p x, l)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementation: \textsc{Remove}}
\begin{lstlisting}
type 'a t =
  | Node of float * 'a * 'a t * 'a t
  | Empty

val remove : 'a t -> 'a t

let rec remove = function
  | Empty ->
    failwith "Can't remove from an empty tree."
  | Node (p, x, l, Empty) -> l
  | Node (p, x, Empty, r) -> r
  | Node (p, x, (Node (lp, lx, _, _) as l),
                (Node (rp, rx, _, _) as r)) ->
    if lp >= rp then
      Node (lp, lx, remove l, r)
    else Node (rp, rx, l, remove r)
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Implementation: Performance}
\begin{itemize}
\item \textsc{Peek} is $O(1)$, which is great! \pause
\item The tree might become unbalanced. What happens then? \pause
\item \textsc{Remove} is worst-case $O(n)$, \textsc{Insert} is worst-case $O(n)$.
\item We try to mitigate it by switching which side we \textsc{Insert} on. \pause
\item Could use a slightly more complicated heap data structure.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Attributions}

\begin{itemize}
\item Priority queue code taken from Chapter 2.1 of the OCaml manual.
\end{itemize}
\end{frame}

\end{document}

% vim: set expandtab sts=2 sw=2 autoindent :
